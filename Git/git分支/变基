在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。
merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。
例:
$ git checkout C1
$ git merge C2
C1为基础，应用C2的修改进行合并。

还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 
在 Git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。
例子:
$ git checkout C4
$ git rebase C3
C3为基础，应用C4的修改进行变基。
它的原理是首先找到这两个分支（即当前分支 C4、变基操作的目标基底分支 C3） 的最近共同祖先 C2，
然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 

这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 
你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。
一般我们使用变基的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。



变基的风险
变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 
如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，
此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，
如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。
如果你真的遭遇了类似的处境，用变基解决变基

